(function() {

"use strict";

angular.module("BitriseWorkflowEditor").factory("Step", function(stringService, Variable) {

	var Step = function(id) {
		this.id = id;
		this.cvs;
		this.steplibSourceURL;
		this.version;
		this.title;
		this.summary;
		this.description;
		this.sourceURL;
		this.iconURL;
		this.typeTags;
		this.inputs;
		this.outputs;
		this.stepConfigs = [];
	};

	Step.validateStepConfig = function(stepConfig) {
		if (!_.isObject(stepConfig) || angular.isArray(stepConfig)) {
			throw new TypeError("<%= data.strings.step.step_config_not_object %>");
		}

		var stringKeys = ["title", "summary", "description", "website", "source_code_url", "support_url", "run_if"];
		var booleanKeys = ["is_requires_admin_user", "is_always_run", "is_skippable", "is_dont_change_value", "is_template"];
		var dateKeys = ["published_at"]
		var objectKeys = ["source", "asset_urls", "deps"];
		var arrayKeys = ["host_os_tags", "project_type_tags", "type_tags", "inputs", "outputs"];
		var arrayOfStringsKeys = ["host_os_tags", "project_type_tags", "type_tags"];

		_.each(stepConfig, function(aValue, aKey) {
			var stringReplaceParameters = {
				key: aKey
			};

			if (_.contains(stringKeys, aKey) && typeof aValue != "string") {
				throw new TypeError(stringService.stringReplacedWithParameters("<%= data.strings.step.value_not_string %>", stringReplaceParameters));
			}
			else if (_.contains(booleanKeys, aKey) && typeof aValue != "boolean") {
				throw new TypeError(stringService.stringReplacedWithParameters("<%= data.strings.step.value_not_boolean %>", stringReplaceParameters));
			}
			else if (_.contains(dateKeys, aKey)) {
				try {
					var date = new Date(aValue);

					if (isNaN(date.getTime())) {
						throw date;
					}
				}
				catch (date) {
					throw new TypeError(stringService.stringReplacedWithParameters("<%= data.strings.step.value_not_date %>", stringReplaceParameters));
				}
			}
			else if (_.contains(objectKeys, aKey) && (!_.isObject(aValue) || angular.isArray(aValue))) {
				throw new TypeError(stringService.stringReplacedWithParameters("<%= data.strings.step.value_not_object %>", stringReplaceParameters));
			}
			else if (_.contains(arrayKeys, aKey)) {
				if (!angular.isArray(aValue)) {
					throw new TypeError(stringService.stringReplacedWithParameters("<%= data.strings.step.value_not_array %>", stringReplaceParameters));
				}

				if (_.contains(arrayOfStringsKeys, aKey)) {
					_.each(aValue, function(arrayValue) {
						if (typeof arrayValue != "string") {
							throw new TypeError(stringService.stringReplacedWithParameters("<%= data.strings.step.value_not_array_of_strings %>", stringReplaceParameters));
						}
					});
				}
			}
		});

		if (stepConfig.source) {
			if (stepConfig.source.git && (typeof stepConfig.source.git != "string" || !stepConfig.source.commit || typeof stepConfig.source.commit != "string")) {
				throw new TypeError("<%= data.strings.step.invalid_source %>");
			}
		}

		if (stepConfig.asset_urls) {
			if (stepConfig.asset_urls["icon.svg"] && typeof stepConfig.asset_urls["icon.svg"] != "string") {
				throw new TypeError("<%= data.strings.step.invalid_asset_urls %>");
			}
			if (stepConfig.asset_urls["icon.png"] && typeof stepConfig.asset_urls["icon.png"] != "string") {
				throw new TypeError("<%= data.strings.step.invalid_asset_urls %>");
			}
		}

		_.each(_.union(stepConfig.inputs, stepConfig.outputs), function(variableConfig) {
			try {
				Variable.validateVariableConfig(variableConfig);
			}
			catch (error) {
				var stepError = angular.copy(error);
				stepError.message = "<%= data.strings.step.append_input_error_prefix %>" + stepError.message;

				throw stepError;
			}
		});
	};

	Step.createFromStepConfig = function(stepConfig) {
		var step = new Step();
		step.appendStepConfig(stepConfig);

		return step;
	};

	Step.prototype.appendStepConfig = function(stepConfig) {
		if (stepConfig.title !== undefined) {
			this.title = stepConfig.title;
		}

		if (stepConfig.summary !== undefined) {
			this.summary = stepConfig.summary;
		}

		if (stepConfig.description !== undefined) {
			this.description = stepConfig.description;
		}

		if (stepConfig.source_code_url !== undefined) {
			this.sourceURL = stepConfig.source_code_url;
		}

		if (stepConfig.asset_urls) {
			if (stepConfig.asset_urls["icon.svg"]) {
				this.iconURL = stepConfig.asset_urls["icon.svg"];
			}
			else if (stepConfig.asset_urls["icon.png"]) {
				this.iconURL = stepConfig.asset_urls["icon.png"];
			}
		}

		if (stepConfig.is_always_run !== undefined) {
			this.isAlwaysRun = stepConfig.is_always_run;
		}

		if (stepConfig.type_tags !== undefined) {
			this.typeTags = stepConfig.type_tags;
		}

		var self = this;
		_.each([stepConfig.inputs, stepConfig.outputs], function(aVariableConfigs) {
			var variablesTargetKey = aVariableConfigs == stepConfig.inputs ? "inputs" : "outputs";

			if (aVariableConfigs !== undefined) {
				if (self[variablesTargetKey] === undefined) {
					self[variablesTargetKey] = [];
				}

				_.each(aVariableConfigs, function(aVariableConfig) {
					var variable = Variable.createFromVariableConfig(aVariableConfig);

					var indexOfVariableInStep = _.findIndex(self[variablesTargetKey], {
						key: variable.key
					});

					if (indexOfVariableInStep == -1) {
						self[variablesTargetKey].push(variable);
					}
					else {
						self[variablesTargetKey].splice(indexOfVariableInStep, 1, variable);
					}
				});
			}
		});

		this.stepConfigs.push(stepConfig);
	};

	Step.prototype.clear = function() {
		this.title = undefined;
		this.summary = undefined;
		this.description = undefined;
		this.sourceURL = undefined;
		this.iconURL = undefined;
		this.isAlwaysRun = undefined;
		this.typeTags = undefined;
		this.inputs = undefined;
		this.outputs = undefined;

		this.stepConfigs = [];
	};

	Step.prototype.isVerified = function() {
		if (this.sourceURL === undefined) {
			return undefined;
		}

		var regexpForVerifiedStepSourceURL = new RegExp("^(?:https?:\/\/)?(?:www.)?github\.com\/(?:bitrise-steplib|bitrise-io)\/.+");

		return regexpForVerifiedStepSourceURL.test(this.sourceURL);
	};

	Step.prototype.requestedVersion = function() {
		if (this.cvs.indexOf("@") == -1) {
			return null;
		}

		return this.version;
	};

	return Step;

});

angular.module("BitriseWorkflowEditor").filter("normalizedStepIconURL", function() {

	return function(step) {
		return step && step.iconURL ? step.iconURL : "<%= image_path('step/icon-default.svg') %>";
	};

});

angular.module("BitriseWorkflowEditor").filter("stepSourceCSSClass", function() {

	return function(step) {
		if (step && step.sourceURL) {
			var regexpForGithubStepSourceURL = new RegExp("^(?:https?:\/\/)?(?:www.)?github\.com\/.+");
			if (regexpForGithubStepSourceURL.test(step.sourceURL)) {
				return "github";
			}

			var regexpForBitbucketStepSourceURL = new RegExp("^(?:https?:\/\/)?(?:www.)?bitbucket\.(?:com|org)\/.+");
			if (regexpForBitbucketStepSourceURL.test(step.sourceURL)) {
				return "bitbucket";
			}
			
			var regexpForGitlabStepSourceURL = new RegExp("^(?:https?:\/\/)?(?:www.)?gitlab\.com\/.+");
			if (regexpForGitlabStepSourceURL.test(step.sourceURL)) {
				return "gitlab";
			}
		}

		return "unknown";
	};

});

})();
