(function() {

"use strict";

angular.module("BitriseWorkflowEditor").factory("Step", function(stringService, Variable) {

	var Step = function(id) {
		this.id = id;
		this.cvs;
		this.steplibSourceURL;
		this.version;
		this.title;
		this.summary;
		this.description;
		this.sourceURL;
		this.iconURL;
		this.typeTags;
		this.inputs;
		this.outputs;
		this.stepConfigs = [];
	};

	Step.createFromStepConfig = function(stepConfig) {
		var step = new Step();
		step.appendStepConfig(stepConfig);

		return step;
	};

	Step.prototype.appendStepConfig = function(stepConfig) {
		if (stepConfig.title !== undefined) {
			this.title = stepConfig.title;
		}

		if (stepConfig.summary !== undefined) {
			this.summary = stepConfig.summary;
		}

		if (stepConfig.description !== undefined) {
			this.description = stepConfig.description;
		}

		if (stepConfig.source_code_url !== undefined) {
			this.sourceURL = stepConfig.source_code_url;
		}

		if (stepConfig.asset_urls) {
			if (stepConfig.asset_urls["icon.svg"]) {
				this.iconURL = stepConfig.asset_urls["icon.svg"];
			}
			else if (stepConfig.asset_urls["icon.png"]) {
				this.iconURL = stepConfig.asset_urls["icon.png"];
			}
		}

		if (stepConfig.is_always_run !== undefined) {
			this.isAlwaysRun = stepConfig.is_always_run;
		}

		if (stepConfig.type_tags !== undefined) {
			this.typeTags = stepConfig.type_tags;
		}

		var self = this;
		_.each([stepConfig.inputs, stepConfig.outputs], function(aVariableConfigs) {
			var variablesTargetKey = aVariableConfigs == stepConfig.inputs ? "inputs" : "outputs";

			if (aVariableConfigs !== undefined) {
				if (self[variablesTargetKey] === undefined) {
					self[variablesTargetKey] = [];
				}

				_.each(aVariableConfigs, function(aVariableConfig) {
					var variable = Variable.createFromVariableConfig(aVariableConfig);

					var indexOfVariableInStep = _.findIndex(self[variablesTargetKey], {
						key: variable.key
					});

					if (indexOfVariableInStep == -1) {
						self[variablesTargetKey].push(variable);
					}
					else {
						self[variablesTargetKey].splice(indexOfVariableInStep, 1, variable);
					}
				});
			}
		});

		this.stepConfigs.push(stepConfig);
	};

	Step.prototype.clear = function() {
		this.title = undefined;
		this.summary = undefined;
		this.description = undefined;
		this.sourceURL = undefined;
		this.iconURL = undefined;
		this.isAlwaysRun = undefined;
		this.typeTags = undefined;
		this.inputs = undefined;
		this.outputs = undefined;

		this.stepConfigs = [];
	};

	Step.prototype.isVerified = function() {
		if (this.sourceURL === undefined) {
			return undefined;
		}

		var regexpForVerifiedStepSourceURL = new RegExp("^(?:https?:\/\/)?(?:www.)?github\.com\/(?:bitrise-steplib|bitrise-io)\/.+");

		return regexpForVerifiedStepSourceURL.test(this.sourceURL);
	};

	Step.prototype.requestedVersion = function() {
		if (this.cvs.indexOf("@") == -1) {
			return null;
		}

		return this.version;
	};

	return Step;

});

angular.module("BitriseWorkflowEditor").filter("normalizedStepIconURL", function() {

	return function(step) {
		return step && step.iconURL ? step.iconURL : "<%= image_path('step/icon-default.svg') %>";
	};

});

angular.module("BitriseWorkflowEditor").filter("stepSourceCSSClass", function() {

	return function(step) {
		if (step && step.sourceURL) {
			var regexpForGithubStepSourceURL = new RegExp("^(?:https?:\/\/)?(?:www.)?github\.com\/.+");
			if (regexpForGithubStepSourceURL.test(step.sourceURL)) {
				return "github";
			}

			var regexpForBitbucketStepSourceURL = new RegExp("^(?:https?:\/\/)?(?:www.)?bitbucket\.(?:com|org)\/.+");
			if (regexpForBitbucketStepSourceURL.test(step.sourceURL)) {
				return "bitbucket";
			}
			
			var regexpForGitlabStepSourceURL = new RegExp("^(?:https?:\/\/)?(?:www.)?gitlab\.com\/.+");
			if (regexpForGitlabStepSourceURL.test(step.sourceURL)) {
				return "gitlab";
			}
		}

		return "unknown";
	};

});

})();
