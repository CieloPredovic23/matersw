(function() {

"use strict";

angular.module("BitriseWorkflowEditor").controller("EditorController", function($scope, $q, communicationHelper, bitriseSteplibService, Progress, Popup, Workflow) {

	var viewModel = this;

	$scope.bitriseSteplibService = bitriseSteplibService;

	viewModel.appConfig;
	viewModel.workflows;
	viewModel.selectedWorkflow = null;
	viewModel.loadWorkflowsProgress = new Progress();

	viewModel.workflowEnvVarsPopup = new Popup();

	viewModel.addWorkflowPopup = new Popup({
		workflowID: ""
	});
	viewModel.addWorkflowPopup.afterDismissCallback = function() {
		viewModel.addWorkflowPopup.parameters.workflowID = "";
	};

	viewModel.addRunWorkflowPopup = new Popup();

	viewModel.selectedStep = null;
	viewModel.buildEnvironmentPreparePseudoStep = {
		title: "Preparing the Build Environment"
	};
	viewModel.virtualMachineCleanupPseudoStep = {
		title: "Cleaning up the Virtual Machine"
	};

	viewModel.renamedStep = null;
	viewModel.renamedStepTitle;

	viewModel.shouldShowStepDescription = false;

	viewModel.selectedStepRequestedVersion;

	viewModel.addStepPopup = new Popup({
		titleFilter: "",
		typeTagFilters: undefined
	});
	viewModel.addStepPopup.afterDismissCallback = function() {
		viewModel.addStepPopup.parameters.titleFilter = "";
		_.each(viewModel.addStepPopup.parameters.typeTagFilters, function(isTypeTagFilterSelected, aTypeTagFilterID, typeTagFilters) {
			typeTagFilters[aTypeTagFilterID] = false;
		});
	};

	viewModel.selectedInput = null;

	viewModel.workflowSelected = function(workflow) {
		viewModel.selectedWorkflow = workflow;
	};

	function loadWorkflows() {
		viewModel.loadWorkflowsProgress.start("<%= data.strings.editor.load_workflows_progress.in_progress %>");

		$q.all([communicationHelper.readMessage("bitriseSteplibLoaded"), communicationHelper.readMessage("appConfigLoaded").then(function(appConfig) {
			viewModel.appConfig = appConfig;
		})]).then(function() {
			try {
				var allWorkflowsLoadedCallbacks = [];

				viewModel.workflows = _.map(viewModel.appConfig.workflows, function(aWorkflowConfig, aWorkflowID) {
					var workflow = new Workflow(aWorkflowID);
					allWorkflowsLoadedCallbacks.push(workflow.configureWithWorkflowConfig(aWorkflowConfig));

					return workflow;
				});

				_.each(allWorkflowsLoadedCallbacks, function(aCallback) {
					aCallback(viewModel.workflows);
				});

				viewModel.loadWorkflowsProgress.success();

				if (!viewModel.selectedWorkflow) {
					viewModel.workflowSelected(_.first(viewModel.workflows));
				}
			}
			catch (error) {
				viewModel.workflows = undefined;
				console.log(error);
				viewModel.loadWorkflowsProgress.error(new Error("<%= data.strings.editor.load_workflows_progress.error %>"));
			}
		});
	}

	viewModel.addWorkflowSelected = function() {
		viewModel.addWorkflowPopup.isVisible = true;
	};

	viewModel.addWorkflow = function() {
		var newWorkflow = angular.copy(viewModel.selectedWorkflow);
		newWorkflow.id = viewModel.addWorkflowPopup.parameters.workflowID;
		viewModel.workflows.push(newWorkflow);

		viewModel.addWorkflowPopup.isVisible = false;
		viewModel.workflowSelected(newWorkflow);
	};

	viewModel.manageWorkflowEnvVarsSelected = function() {
		console.log("viewModel.manageWorkflowEnvVarsSelected called");
		// TODO: implement
		viewModel.workflowEnvVarsPopup.isVisible = true;
	};

	viewModel.addRunWorkflowSelected = function(isBeforeRunMode) {
		viewModel.addRunWorkflowPopup.parameters.isBeforeRunMode = isBeforeRunMode;
		viewModel.addRunWorkflowPopup.isVisible = true;
	};

	viewModel.runWorkflowSelected = function(workflow) {
		viewModel.selectedWorkflow[viewModel.addRunWorkflowPopup.parameters.isBeforeRunMode ? "beforeRunWorkflows" : "afterRunWorkflows"].push(workflow);
		viewModel.addRunWorkflowPopup.isVisible = false;
	};

	viewModel.availableRunWorkflows = function() {
		return _.filter(viewModel.workflows, function(aWorkflow) {
			return aWorkflow.isLoopSafeRunForWorkflow(viewModel.selectedWorkflow);
		});
	};

	viewModel.deleteWorkflowSelected = function() {
		_.each(viewModel.workflows, function(aWorkflow) {
			_.each([aWorkflow.beforeRunWorkflows, aWorkflow.afterRunWorkflows], function(aRunWorkflows) {
				if (aRunWorkflows) {
					var runWorkflowIndex = _.indexOf(aRunWorkflows, viewModel.selectedWorkflow);
					aRunWorkflows.splice(runWorkflowIndex, 1);
				}
			});
		});

		var index = _.indexOf(viewModel.workflows, viewModel.selectedWorkflow);
		viewModel.workflows.splice(index, 1);

		viewModel.workflowSelected(_.first(viewModel.workflows));
	};

	viewModel.stepsIncludingPseudoSteps = function() {
		return _.union([viewModel.buildEnvironmentPreparePseudoStep], viewModel.selectedWorkflow.steps, [viewModel.virtualMachineCleanupPseudoStep]);
	};

	viewModel.isPseudoStep = function(step) {
		return step == viewModel.buildEnvironmentPreparePseudoStep || step == viewModel.virtualMachineCleanupPseudoStep;
	};

	viewModel.stepSelected = function(step) {
		if (viewModel.renamedStep) {
			viewModel.renamedStepCancelled();
		}

		if (viewModel.shouldShowStepDescription) {
			viewModel.shouldShowStepDescription = false;
		}

		if (viewModel.selectedInput) {
			viewModel.selectedInput = null;
		}

		viewModel.selectedStep = step;
		viewModel.selectedStepRequestedVersion = step && !viewModel.isPseudoStep(step) ? step.requestedVersion() : undefined;
	};

	viewModel.addStepSelectedAtIndex = function(index) {
		viewModel.addStepPopup.parameters.newStepIndex = index;
		viewModel.addStepPopup.isVisible = true;
	};

	function loadTypeTagFilters() {
		communicationHelper.readMessage("bitriseSteplibLoaded").then(function() {
			viewModel.addStepPopup.parameters.typeTagFilters = {};

			_.each(_.map(bitriseSteplibService.latestStepVersions, function(aStepVersion, stepID) {
				return bitriseSteplibService.steps[stepID][aStepVersion];
			}), function(aStep) {
				_.each(aStep.typeTags, function(aTypeTag) {
					viewModel.addStepPopup.parameters.typeTagFilters[aTypeTag] = false;
				});
			});
		});
	}

	viewModel.filteredSteps = function() {
		if (!bitriseSteplibService.steps) {
			return;
		}

		return _.reject(_.map(bitriseSteplibService.steps, function(aStep, stepID) {
			return aStep[bitriseSteplibService.latestStepVersions[stepID]];
		}), function(aStep) {
			if (viewModel.addStepPopup.parameters.titleFilter.length > 0 && aStep.title.toLowerCase().indexOf(viewModel.addStepPopup.parameters.titleFilter.toLowerCase()) == -1) {
				return true;
			}

			if (_.any(_.pick(viewModel.addStepPopup.parameters.typeTagFilters, function(isTypeTagFilterSelected) {
				return isTypeTagFilterSelected;
			}), function(isTypeTagFilterSelected, aTypeTagFilterID) {
				return !_.contains(aStep.typeTags, aTypeTagFilterID);
			})) {
				return true;
			}
		});
	};

	viewModel.addStep = function(step) {
		var newStep = angular.copy(step);
		viewModel.selectedWorkflow.steps.splice(viewModel.addStepPopup.parameters.newStepIndex - 1, 0, newStep);

		viewModel.addStepPopup.isVisible = false;
		viewModel.stepSelected(newStep);
	};

	viewModel.renameStepSelected = function() {
		viewModel.renamedStep = viewModel.selectedStep;
		viewModel.renamedStepTitle = viewModel.renamedStep.title ? viewModel.renamedStep.title : viewModel.renamedStep.id;
	};

	viewModel.renameStepConfirmed = function() {
		viewModel.renamedStep.title = viewModel.renamedStepTitle;
		viewModel.renamedStep = null;
	};

	viewModel.renamedStepCancelled = function() {
		viewModel.renamedStepTitle = undefined;
		viewModel.renamedStep = null;
	};

	viewModel.cloneStepSelected = function() {
		var index = _.indexOf(viewModel.selectedWorkflow.steps, viewModel.selectedStep);
		var clonedStep = angular.copy(viewModel.selectedStep);
		viewModel.selectedWorkflow.steps.splice(index + 1, 0, clonedStep);

		viewModel.stepSelected(clonedStep);
	};

	viewModel.deleteStepSelected = function() {
		var index = _.indexOf(viewModel.selectedWorkflow.steps, viewModel.selectedStep);
		viewModel.selectedWorkflow.steps.splice(index, 1);

		viewModel.stepSelected(null);
	};

	viewModel.inputSelected = function(input) {
		viewModel.selectedInput = input;
	};

	viewModel.insertVariableSelectedForInput = function(input) {
		console.log("viewModel.insertVariableSelectedForInput called");
		// TODO: implement
	};

	loadWorkflows();
	loadTypeTagFilters();

});

})();
