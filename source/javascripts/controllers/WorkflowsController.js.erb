(function() {

"use strict";

angular.module("BitriseWorkflowEditor").controller("WorkflowsController", function($scope, $rootScope, $q, $filter, bitriseSteplibService, Progress, Popup, Workflow, Variable) {

	var viewModel = this;

	$scope.bitriseSteplibService = bitriseSteplibService;
	$scope.Variable = Variable;

	viewModel.appConfig;
	var appConfigLoadDeferred = $q.defer();
	viewModel.workflows;
	viewModel.selectedWorkflow = null;
	viewModel.loadWorkflowsProgress = new Progress();

	viewModel.workflowEnvVarsPopup = new Popup();
	viewModel.workflowEnvVarsPopup.beforeAppearCallback = function() {
		if (!viewModel.workflowEnvVarsPopup.parameters.templateLoadProgress) {
			viewModel.workflowEnvVarsPopup.parameters.templateLoadProgress = new Progress();
			viewModel.workflowEnvVarsPopup.parameters.templateLoadProgress.start("<%= data[:strings][:env_var_editor][:template_load_inprogress] %>");
		}

		$rootScope.$on("EnvVarsController::loadedAndReady", function() {
			appConfigLoadDeferred.promise.then(function() {
				$rootScope.$emit("EnvVarsController::configure", {
					source: "workflow-env-vars",
					envVars: viewModel.selectedWorkflow.envVars
				});
			});
		});
	};

	viewModel.addWorkflowPopup = new Popup({
		workflowID: ""
	});
	viewModel.addWorkflowPopup.afterDismissCallback = function() {
		viewModel.addWorkflowPopup.parameters.workflowID = "";
	};

	viewModel.addRunWorkflowPopup = new Popup();

	viewModel.selectedStep = null;
	viewModel.buildEnvironmentPreparePseudoStep = {};
	viewModel.virtualMachineCleanupPseudoStep = {};

	viewModel.renamedStep = null;
	viewModel.renamedStepTitle;

	viewModel.shouldShowStepDescription = false;

	viewModel.selectedStepRequestedVersion;

	viewModel.addStepPopup = new Popup({
		titleFilter: "",
		availableTypeTagFilters: undefined,
		typeTagFilter: null
	});
	viewModel.addStepPopup.beforeAppearCallback = function() {
		if (viewModel.addStepPopup.parameters.availableTypeTagFilters) {
			return;
		}

		viewModel.addStepPopup.parameters.availableTypeTagFilters = [];

		_.each(_.map(bitriseSteplibService.latestStepVersions, function(aStepVersion, stepID) {
			return bitriseSteplibService.steps[stepID][aStepVersion];
		}), function(aStep) {
			viewModel.addStepPopup.parameters.availableTypeTagFilters = _.union(viewModel.addStepPopup.parameters.availableTypeTagFilters, aStep.typeTags());
		});

		viewModel.addStepPopup.parameters.availableTypeTagFilters = _.uniq(viewModel.addStepPopup.parameters.availableTypeTagFilters);
	};
	viewModel.addStepPopup.afterDismissCallback = function() {
		viewModel.addStepPopup.parameters.titleFilter = "";
		viewModel.addStepPopup.parameters.typeTagFilter = null;
	};

	viewModel.selectedInput = null;
	viewModel.insertVariablePopup = new Popup({
		appConfig: undefined,
		selectedWorkflow: undefined,
		selectedStep: undefined,
		targetInput: undefined,
		insertStartPosition: undefined,
		insertEndPosition: undefined
	});

	viewModel.workflowSelectedGetterSetter = function(workflow) {
		return workflow === undefined ? viewModel.selectedWorkflow : workflowSelected(workflow);
	};

	function workflowSelected(workflow) {
		if (workflow == viewModel.selectedWorkflow) {
			return;
		}

		if (viewModel.selectedStep) {
			viewModel.stepSelected(null);
		}
		
		viewModel.selectedWorkflow = workflow;
	}

	$rootScope.$on("MainController::appConfigLoaded", function(event, appConfig) {
		viewModel.appConfig = appConfig;
		appConfigLoadDeferred.resolve();
		loadWorkflows();
	});

	$rootScope.$on("MainController::discardChanges", function(event, appConfig) {
		viewModel.selectedWorkflow = null;
		viewModel.appConfig = appConfig;
		loadWorkflows();
	});

	$rootScope.$on("MainController::requestingAppConfigUpdateBeforeSave", function() {
		viewModel.appConfig.workflows = {};

		_.each(viewModel.workflows, function(aWorkflow) {
			viewModel.appConfig.workflows[aWorkflow.id] = {
				envs: _.map(aWorkflow.envVars, function(anEnvVar) {
					return anEnvVar.userVariableConfig;
				}),
				steps: _.map(aWorkflow.steps, function(aStep) {
					var wrappedUserStepConfig = {};
					wrappedUserStepConfig[aStep.cvs] = aStep.userStepConfig;
					
					return wrappedUserStepConfig;
				}),
				before_run: _.map(aWorkflow.beforeRunWorkflows, function(aWorkflow) {
					return aWorkflow.id;
				}),
				after_run: _.map(aWorkflow.afterRunWorkflows, function(aWorkflow) {
					return aWorkflow.id;
				})
			};
		});
	});

	function loadWorkflows() {
		viewModel.loadWorkflowsProgress.start("<%= data[:strings][:workflows][:load_workflows_progress][:in_progress] %>");

		$q.all([bitriseSteplibService.load(), appConfigLoadDeferred.promise]).then(function() {
			try {
				var allWorkflowsLoadedCallbacks = [];

				viewModel.workflows = _.map(viewModel.appConfig.workflows, function(aWorkflowConfig, aWorkflowID) {
					var workflow = new Workflow(aWorkflowID);
					allWorkflowsLoadedCallbacks.push(workflow.configureWithWorkflowConfig(aWorkflowConfig));

					return workflow;
				});

				_.each(allWorkflowsLoadedCallbacks, function(aCallback) {
					aCallback(viewModel.workflows);
				});

				viewModel.loadWorkflowsProgress.success();

				if (!viewModel.selectedWorkflow) {
					workflowSelected(_.first(viewModel.workflows));
				}
			}
			catch (error) {
				viewModel.workflows = undefined;
				console.log(error);
				viewModel.loadWorkflowsProgress.error(new Error("<%= data[:strings][:workflows][:load_workflows_progress][:error] %>"));
			}
		});
	}

	viewModel.addWorkflowSelected = function() {
		viewModel.addWorkflowPopup.isVisible = true;
	};

	viewModel.addWorkflow = function() {
		var newWorkflow = angular.copy(viewModel.selectedWorkflow);
		newWorkflow.id = viewModel.addWorkflowPopup.parameters.workflowID;
		viewModel.workflows.push(newWorkflow);

		viewModel.addWorkflowPopup.isVisible = false;
		workflowSelected(newWorkflow);
	};

	viewModel.manageWorkflowEnvVarsSelected = function() {
		viewModel.workflowEnvVarsPopup.isVisible = true;
	};

	viewModel.addRunWorkflowSelected = function(isBeforeRunMode) {
		viewModel.addRunWorkflowPopup.parameters.isBeforeRunMode = isBeforeRunMode;
		viewModel.addRunWorkflowPopup.isVisible = true;
	};

	viewModel.runWorkflowSelected = function(workflow) {
		viewModel.selectedWorkflow[viewModel.addRunWorkflowPopup.parameters.isBeforeRunMode ? "beforeRunWorkflows" : "afterRunWorkflows"].push(workflow);
		viewModel.addRunWorkflowPopup.isVisible = false;
	};

	viewModel.availableRunWorkflows = function() {
		return _.filter(viewModel.workflows, function(aWorkflow) {
			return aWorkflow.isLoopSafeRunForWorkflow(viewModel.selectedWorkflow);
		});
	};

	viewModel.deleteWorkflowSelected = function() {
		_.each(viewModel.workflows, function(aWorkflow) {
			_.each([aWorkflow.beforeRunWorkflows, aWorkflow.afterRunWorkflows], function(aRunWorkflows) {
				if (aRunWorkflows) {
					var runWorkflowIndex = _.indexOf(aRunWorkflows, viewModel.selectedWorkflow);
					aRunWorkflows.splice(runWorkflowIndex, 1);
				}
			});
		});

		var index = _.indexOf(viewModel.workflows, viewModel.selectedWorkflow);
		viewModel.workflows.splice(index, 1);

		workflowSelected(_.first(viewModel.workflows));
	};

	viewModel.stepsIncludingPseudoSteps = function() {
		return _.union([viewModel.buildEnvironmentPreparePseudoStep], viewModel.selectedWorkflow.steps, [viewModel.virtualMachineCleanupPseudoStep]);
	};

	viewModel.stepType = function(step) {
		if (step == viewModel.buildEnvironmentPreparePseudoStep || step == viewModel.virtualMachineCleanupPseudoStep) {
			return "pseudo-step";
		}
		if (step.id === undefined) {
			return "errorous-step";
		}
		if (bitriseSteplibService.isBitriseSteplibStep(step)) {
			return "bitrise-steplib-step";
		}

		return "non-bitrise-steplib-step";
	}

	viewModel.stepDisplayName = function(step) {
		if (step == viewModel.buildEnvironmentPreparePseudoStep) {
			return "<%= data[:strings][:workflows][:steps][:pseudo_preparing] %>";
		}
		if (step == viewModel.virtualMachineCleanupPseudoStep) {
			return "<%= data[:strings][:workflows][:steps][:pseudo_cleaning] %>";
		}
		if (step.id === undefined) {
			return step.cvs;
		}
		if (bitriseSteplibService.isBitriseSteplibStep(step)) {
			return step.title();
		}

		return step.id;
	};

	viewModel.stepSelected = function(step) {
		if (step == viewModel.selectedStep) {
			return;
		}

		if (viewModel.renamedStep) {
			viewModel.renamedStepCancelled();
		}

		if (viewModel.shouldShowStepDescription) {
			viewModel.shouldShowStepDescription = false;
		}

		if (viewModel.selectedInput) {
			viewModel.selectedInput = null;
		}

		viewModel.selectedStep = step;
		viewModel.selectedStepRequestedVersion = step && viewModel.stepType(step) == "bitrise-steplib-step" ? step.requestedVersion() : undefined;
	};

	viewModel.addStepSelectedAtIndex = function(index) {
		viewModel.addStepPopup.parameters.newStepIndex = index;
		viewModel.addStepPopup.isVisible = true;
	};

	viewModel.filteredSteps = function() {
		if (!bitriseSteplibService.steps) {
			return;
		}

		return _.reject(_.map(bitriseSteplibService.steps, function(aStep, stepID) {
			return aStep[bitriseSteplibService.latestStepVersions[stepID]];
		}), function(aStep) {
			if (viewModel.addStepPopup.parameters.titleFilter.length > 0 && aStep.title().toLowerCase().indexOf(viewModel.addStepPopup.parameters.titleFilter.toLowerCase()) == -1) {
				return true;
			}

			if (viewModel.addStepPopup.parameters.typeTagFilter && !_.contains(aStep.typeTags(), viewModel.addStepPopup.parameters.typeTagFilter)) {
				return true;
			}
		});
	};

	viewModel.addStep = function(step) {
		var newStep = angular.copy(step);
		newStep.userStepConfig = {};
		viewModel.selectedWorkflow.steps.splice(viewModel.addStepPopup.parameters.newStepIndex - 1, 0, newStep);

		viewModel.addStepPopup.isVisible = false;
		viewModel.stepSelected(newStep);
	};

	viewModel.renameStepSelected = function() {
		viewModel.renamedStep = viewModel.selectedStep;
		viewModel.renamedStepTitle = viewModel.renamedStep.title() ? viewModel.renamedStep.title() : viewModel.renamedStep.id;
	};

	viewModel.renameStepConfirmed = function() {
		viewModel.renamedStep.title(viewModel.renamedStepTitle);
		viewModel.renamedStep = null;
	};

	viewModel.renamedStepCancelled = function() {
		viewModel.renamedStepTitle = undefined;
		viewModel.renamedStep = null;
	};

	viewModel.cloneStepSelected = function() {
		var index = _.indexOf(viewModel.selectedWorkflow.steps, viewModel.selectedStep);
		var clonedStep = angular.copy(viewModel.selectedStep);
		viewModel.selectedWorkflow.steps.splice(index + 1, 0, clonedStep);

		viewModel.stepSelected(clonedStep);
	};

	viewModel.deleteStepSelected = function() {
		var index = _.indexOf(viewModel.selectedWorkflow.steps, viewModel.selectedStep);
		viewModel.selectedWorkflow.steps.splice(index, 1);

		viewModel.stepSelected(null);
	};

	viewModel.inputFromStepDefaultInputConfig = function(step, defaultInputConfig) {
		var userInputConfig = step.userStepConfig ? _.find(step.userStepConfig.inputs, function(aUserInputConfig) {
			return Variable.keyFromVariableConfig(aUserInputConfig) == Variable.keyFromVariableConfig(defaultInputConfig);
		}) : undefined;

		var input = new Variable(userInputConfig, defaultInputConfig);

		$scope.$on("$destroy", $scope.$watch(function() {
			return !input.userInputConfig || _.isEmpty(input.userInputConfig);
		}, function(isUserInputConfigEmptyNow, wasUserInputConfigEmptyBefore) {
			if (isUserInputConfigEmptyNow === true && wasUserInputConfigEmptyBefore === false) {
				if (!step.userStepConfig || !step.userStepConfig.inputs) {
					return;
				}

				var indexOfUserInputConfig = _.findIndex(step.userStepConfig.inputs, function(aUserInputConfig) {
					return Variable.keyFromVariableConfig(aUserInputConfig) == input.key();
				});

				step.userStepConfig.inputs.splice(indexOfUserInputConfig, 1);
			}

			if (isUserInputConfigEmptyNow === false && wasUserInputConfigEmptyBefore === true) {
				if (!step.userStepConfig) {
					step.userStepConfig = {};
				}

				if (!step.userStepConfig.inputs) {
					step.userStepConfig.inputs = [];
				}

				var indexOfUserInputConfig = _.findIndex(step.userStepConfig.inputs, function(aUserInputConfig) {
					return Variable.keyFromVariableConfig(aUserInputConfig) == input.key();
				});

				if (indexOfUserInputConfig != -1) {
					step.userStepConfig.inputs.splice(indexOfUserInputConfig, 1);
				}

				step.userStepConfig.inputs.push(input.userInputConfig);
			}
		}));

		return input;
	};

	viewModel.outputFromDefaultOutputConfig = function(defaultOutputConfig) {
		return new Variable(undefined, defaultOutputConfig);
	};

	viewModel.inputSelected = function(input) {
		viewModel.selectedInput = input;
		viewModel.insertVariablePopup.parameters.insertStartPosition = viewModel.insertVariablePopup.parameters.insertEndPosition = viewModel.selectedInput ? viewModel.selectedInput.value.length : 0;
	};

	viewModel.inputBlurred = function(event) {
		viewModel.insertVariablePopup.parameters.insertStartPosition = event.target.selectionStart;
		viewModel.insertVariablePopup.parameters.insertEndPosition = event.target.selectionEnd;
	};

	viewModel.insertVariableSelected = function() {
		viewModel.insertVariablePopup.parameters.appConfig = viewModel.appConfig;
		viewModel.insertVariablePopup.parameters.selectedWorkflow = viewModel.selectedWorkflow;
		viewModel.insertVariablePopup.parameters.selectedStep = viewModel.selectedStep;
		viewModel.insertVariablePopup.parameters.targetInput = viewModel.selectedInput;
		viewModel.insertVariablePopup.isVisible = true;
	};

	viewModel.insertVariable = function(variable) {
		var oldValue = viewModel.selectedInput.value;
		viewModel.selectedInput.value = oldValue.slice(0, viewModel.insertVariablePopup.parameters.insertStartPosition) + $filter("prettifiedVariableKey")(variable) + oldValue.slice(viewModel.insertVariablePopup.parameters.insertEndPosition);
		viewModel.insertVariablePopup.parameters.insertStartPosition = viewModel.insertVariablePopup.parameters.insertEndPosition = viewModel.selectedInput.value.length;
		viewModel.insertVariablePopup.isVisible = false;
	};

	$rootScope.$emit("MainController::menuContentIsLoadedAndReady");

});

})();
