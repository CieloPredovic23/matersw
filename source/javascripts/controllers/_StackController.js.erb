(function() {
	"use strict";

	angular
		.module("BitriseWorkflowEditor")
		.controller("StackController", function(
			$q,
			$scope,
			$rootScope,
			stringService,
			appService,
			Workflow,
			Stack,
			MachineType,
			planServiceUtil,
			dateService,
			launchDarklyService
		) {
			var viewModel = this;

			viewModel.workflows;
			$scope.Stack = Stack;
			$scope.MachineType = MachineType;
			$scope.appService = appService;
			$scope.showMachineCreditCost = false;
			$scope.dateService = dateService;
			viewModel.buildMachineDeprecationData;
			viewModel.defaultDockerImagesByStackIDs = {
				"linux-docker-android": "bitriseio/android-ndk:pinned",
				"linux-docker-android-20.04": "bitriseio/android-ndk-20.04:pinned",
			};
			viewModel.machineTypeTagNotes = {
				"gen1": "<%= data[:strings][:stack][:machine_type_notes][:gen1] %>",
				"gen2": "<%= data[:strings][:stack][:machine_type_notes][:gen2] %>"
			};

			viewModel.stackMachineMap = appService.availableStacks().reduce(function(result, stack) {
				var stackMachineTypes = _.filter(MachineType.all, function(machineType) {
					if (machineType.availableOnStacks) {
						return machineType.availableOnStacks.indexOf(stack.id) > -1;
					}
					return machineType.stackType === stack.type;
				});
				result[stack.id] = _.groupBy(stackMachineTypes, 'chip');

				return result;
			}, {});

			viewModel.getStackMachineTypeChipOrder = function(stackId) {
				if (viewModel.stackMachineMap) {
					return Object.keys(viewModel.stackMachineMap[stackId] || {}).sort();
				}
				return [];
			}

			viewModel.init = function() {
				appService.getOwnerPlanData().then(() => {
					$scope.showMachineCreditCost = getShowMachineCreditCost();
					configure();
				}).catch(() => {
					$scope.showMachineCreditCost = getShowMachineCreditCost();
					configure();
				});

				loadLaunchDarklyFeatureFlags().then((response) => {
					viewModel.buildMachineDeprecationData = {
						message: buildMachineDeprecationMessageBasedOnGracePeriodDates(response.gracePeriodStartDate, response.gracePeriodEndDate),
						announcementUrl: 'https://www.bitrise.io',
						announcementUrlLabel: 'Read announcement'
					};
				});
			};

			$scope.$on(
				"$destroy",
				$rootScope.$on("MainController::changesDiscarded", function() {
					configure();
				})
			);

			function configure() {
				viewModel.workflows = _.map(appService.appConfig.workflows, function(
					aWorkflowConfig,
					workflowID
				) {
					return new Workflow(workflowID, aWorkflowConfig);
				});
			}

			function loadLaunchDarklyFeatureFlags() {
				return $q(function (resolve, reject) {
					launchDarklyService.initialize().then(() => {
						const ldFlagValue = launchDarklyService.variation("migrate-from-intel-machines-to-apple-silicon", {});

						if (_.size(ldFlagValue) > 0 && ldFlagValue.grace_period_started && ldFlagValue.grace_period_ended) {
							const gracePeriodStartDate = new Date(ldFlagValue.grace_period_started);
							const gracePeriodEndDate = new Date(ldFlagValue.grace_period_ended);

							resolve({gracePeriodStartDate, gracePeriodEndDate});
						}

						reject();
					});
				});
			}

			function buildMachineDeprecationMessageBasedOnGracePeriodDates(startDate, endDate) {
				if (!startDate || !endDate) {
					return;
				}

				const currentDate = new Date();
				if (currentDate < startDate) {
					return "Intel machines will be deprecated. Your builds will be switched over to an Apple Silicon machine on " + dateService.toLocaleMonthDayDateString(startDate) + "."
				} else if (currentDate >= startDate && currentDate <= endDate) {
					return "Deprecated machine type. Your builds now are running on Apple Silicon. You can extend using Intel machines until " + dateService.toLocaleMonthDayDateString(endDate) + "."
				} else if (currentDate > endDate) {
					return "Deprecated machine type. Your builds now are running on Apple Silicon. If youâ€™d like to keep using Intel machines, reach out to support."
				}
			}

			viewModel.stackOptionTitle = function(stack) {
				if (stack === null) {
					return stringService.stringReplacedWithParameters(
						"<%= data[:strings][:stack][:default_stack] %>",
						{
							stack_name: viewModel.stackOptionTitle(appService.stack)
						}
					);
				}

				return stack.name || stack.id;
			};

			viewModel.stackOptions = function() {
				var stacks = appService.availableStacks().concat(Stack.invalidStacks);

				return stacks;
			};

			viewModel.onDefaultStackChange = function() {
				appService.dockerImage = viewModel.defaultDockerImagesByStackIDs[appService.stack.id] ? '' : null;

				var isPreviousMachineTypeAvailable = viewModel.isMachineTypeAvailableForStack(appService.defaultMachineType, appService.stack);

				if (!isPreviousMachineTypeAvailable) {
					viewModel.setDefaultMachineType(viewModel.firstAvailableMachineTypeForStack(appService.stack.id));
				}
			}

			viewModel.stackGetterSetterForWorkflow = function(workflow, shouldNormalize) {
				if (shouldNormalize === undefined) {
					shouldNormalize = false;
				}

				return function(stack) {
					if (stack === null && shouldNormalize) {
						stack = appService.stack;
					}

					var defaultMachineTypeForStack;
					if (stack) {
						var previousMachineType = viewModel.workflowMachineType(workflow);
						var isPreviousMachineTypeAvailable = viewModel.isMachineTypeAvailableForStack(previousMachineType, stack);

						if (isPreviousMachineTypeAvailable) {
							defaultMachineTypeForStack = previousMachineType;
						} else if (MachineType.defaults) {
							defaultMachineTypeForStack = MachineType.defaults[stack.type];
						}
					}
					stack = workflow.stack(stack, defaultMachineTypeForStack);

					if (stack === null && shouldNormalize) {
						return appService.stack;
					}

					return stack;
				};
			};

			viewModel.setDefaultMachineType = function(machineType) {
				if (!machineType.isAvailable) {
					return;
				}

				appService.defaultMachineType = machineType;
			}

			viewModel.setWorkflowMachineType = function(machineType, workflow) {
				if (!machineType.isAvailable) {
					return;
				}

				var stack = viewModel.stackGetterSetterForWorkflow(workflow, true)();
				workflow.machineType(stack.type, machineType, MachineType.all);
			};

			viewModel.workflowMachineType = function(workflow) {
				var stack = viewModel.stackGetterSetterForWorkflow(workflow, true)();
				var workflowMachineType = workflow.machineType(stack.type, undefined, MachineType.all);

				return workflowMachineType || appService.defaultMachineType;
			};

			viewModel.isMachineTypeAvailableForStack = function(previousMachineType, stack) {
				return Object.values(viewModel.stackMachineMap[stack.id] || {}).some(machineTypes =>
					machineTypes.some(machineType => machineType.id === previousMachineType.id && machineType.type === previousMachineType.type)
				);
			};

			viewModel.firstAvailableMachineTypeForStack = function(selectedStackId) {
				return _.find(MachineType.all, function(aMachineType) {
					return _.contains(aMachineType.availableOnStacks, selectedStackId);
				});
			};

			viewModel.descriptionURLForStack = function(stack) {
				if (stack.descriptionURLGen2 !== undefined) {
					return stack.descriptionURLGen2;
				}

				return stack.descriptionURL;
			};

			viewModel.hasDescriptionURLForStack = function(stack) {
				return !!viewModel.descriptionURLForStack(stack);
			}

			viewModel.osForStackWithMachineType = function(stack, machineType) {
				return stack.osForChip[machineType.chip];
			}

			function getShowMachineCreditCost() {
				if (appService.ownerPlanData) {
					return !planServiceUtil.isModernConcurrencyPlan(appService.ownerPlanData.name);
				}
				return true;
			}
		});
})();
