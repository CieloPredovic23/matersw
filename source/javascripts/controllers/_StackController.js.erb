(function() {
	"use strict";

	angular
		.module("BitriseWorkflowEditor")
		.controller("StackController", function(
			$q,
			$scope,
			$rootScope,
			stringService,
			appService,
			Workflow,
			Stack,
			MachineType,
			planServiceUtil,
			dateService,
			requestService,
			appServiceUtil
		) {
			var viewModel = this;

			viewModel.workflows;
			$scope.Stack = Stack;
			$scope.MachineType = MachineType;
			$scope.appService = appService;
			$scope.showMachineCreditCost = false;
			$scope.dateService = dateService;
			viewModel.buildMachineDeprecationData;
			viewModel.defaultDockerImagesByStackIDs = {
				"linux-docker-android": "bitriseio/android-ndk:pinned",
				"linux-docker-android-20.04": "bitriseio/android-ndk-20.04:pinned",
			};
			viewModel.machineTypeTagNotes = {
				"gen1": "<%= data[:strings][:stack][:machine_type_notes][:gen1] %>",
				"gen2": "<%= data[:strings][:stack][:machine_type_notes][:gen2] %>"
			};

			viewModel.stackMachineMap = appService.availableStacks().reduce(function(result, stack) {
				var stackMachineTypes = _.filter(MachineType.all, function(machineType) {
					if (machineType.availableOnStacks) {
						return machineType.availableOnStacks.indexOf(stack.id) > -1;
					}
					return machineType.stackType === stack.type;
				});
				result[stack.id] = _.groupBy(stackMachineTypes, 'chip');

				return result;
			}, {});

			viewModel.getStackMachineTypeChipOrder = function(stackId) {
				if (viewModel.stackMachineMap) {
					return Object.keys(viewModel.stackMachineMap[stackId] || {}).sort();
				}
				return [];
			}

			viewModel.canShowDefaulStackMachines = function() {
				if(appService.stack && appService.stack.isAgentPoolStack()) {
					return false;
				}

				return appService.appDetails.isMachineTypeSelectorAvailable
			}

			viewModel.canShowWorkflowStackMachines = function(workflow) {
				var stack = viewModel.stackGetterSetterForWorkflow(workflow, false)();

				if(stack && stack.isAgentPoolStack()) {
					return false;
				}

				return appService.appDetails.isMachineTypeSelectorAvailable && !!stack;
			}

			// TODO: remove this when rollback feature is released 
			viewModel.showRollbackOption = function() {
				var hasAnyStackRollbackVersion = false;
				_.forEach(appService.availableStacks(), function(stack) {
					if (stack.rollbackVersions) {
						hasAnyStackRollbackVersion = true;
					}
				});
				return hasAnyStackRollbackVersion;
			}

			viewModel.isRollbackCheckboxDisabled = function(workflow) {
				return !appService.getStackRollbackVersion(workflow);
			}

			viewModel.isRollbackVersionEnabledGetterSetter = function(newIsRollbackVersion) {

				if (newIsRollbackVersion === true) {
					appService.rollbackVersion = appService.getStackRollbackVersion();
				} else if (newIsRollbackVersion === false) {
					appService.rollbackVersion = undefined
				}

				return !!appService.rollbackVersion;
			}

			viewModel.isRollbackVersionEnabled = function(workflow) {
				return !!workflow.getRollbackVersion();
			}

			viewModel.isRollbackVersionInBitriseYmlNoLongerAvailable = function(workflow) {
				var isPaying = appService.isOwnerPaying();
				var machineTypeId = appService.defaultMachineType.id;

				if (workflow) {
					return workflow.isRollbackVersionInBitriseYmlNoLongerAvailable(MachineType.all, isPaying);
				}

				var rollbackVersion = appService.savedStack.getRollbackVersion(appService.savedDefaultMachineType.id, isPaying);
				var rollbackVersionInYml = appService.getRollbackVersionFromBitriseYml();

				return rollbackVersionInYml && !angular.equals(rollbackVersion, rollbackVersionInYml);
			}

			viewModel.rollbackVersionGetterSetterForWorkflow = function(workflow) {
				return function(isChecked) {

					if (isChecked === true) {
						var isPaying = appService.isOwnerPaying();

						workflow.setRollbackVersion(isPaying, MachineType.all);
					} else if (isChecked === false) {
						workflow.removeRollbackVersion();
					}

					var isRollbackVersionInYmlNotAvailable = workflow.isRollbackVersionInBitriseYmlNoLongerAvailable(MachineType.all, appService.isOwnerPaying());
					return !!workflow.getRollbackVersion() && !isRollbackVersionInYmlNotAvailable;
				}
			}

			viewModel.init = function() {
				appService.getOwnerPlanData().then(() => {
					$scope.showMachineCreditCost = getShowMachineCreditCost();
					configure();

					appService.setRollbackVersionFromBitriseYml();
				}).catch(() => {
					$scope.showMachineCreditCost = getShowMachineCreditCost();
					configure();
				});

				requestService.getApp(appServiceUtil.getAppSlug()).then((response) => {
					var gracePeriodDates = {};
					if (response.deprecated_machines_replacement_config && response.deprecated_machines_replacement_config.grace_period_started) {
						gracePeriodDates.startsAt = new Date(response.deprecated_machines_replacement_config.grace_period_started);
					}
					if (response.deprecated_machines_replacement_config && response.deprecated_machines_replacement_config.grace_period_ended) {
						gracePeriodDates.endsAt = new Date(response.deprecated_machines_replacement_config.grace_period_ended);
					}
					viewModel.buildMachineDeprecationData = buildMachineDeprecationDataBasedOnGracePeriodDates(gracePeriodDates.startsAt, gracePeriodDates.endsAt);
				});
			};

			$scope.$on(
				"$destroy",
				$rootScope.$on("MainController::changesDiscarded", function() {
					configure();
				})
			);

			function configure() {
				viewModel.workflows = _.map(appService.appConfig.workflows, function(
					aWorkflowConfig,
					workflowID
				) {
					return new Workflow(workflowID, aWorkflowConfig);
				});
			}

			function buildMachineDeprecationDataBasedOnGracePeriodDates(startDate, endDate) {
				if (!startDate || !endDate) {
					return;
				}

				const currentDate = new Date();
				if (currentDate < startDate) {
					return {
						message: "Intel machines will be deprecated. Your Workflows will automatically run on Apple Silicon machines on the " + dateService.toLocaleMonthDayDateString(startDate) + ".",
						linkUrl: 'https://discuss.bitrise.io/t/transitioning-from-apple-intel-to-apple-silicon-helpful-links/22615',
						linkLabel: 'Read announcement.',
					}
				} else if (currentDate >= startDate && currentDate <= endDate) {
					return {
						message: "Deprecated machine type. Workflows running on Intel machines were automatically switched to Apple Silicon machines. To continue using Intel machines until the " + dateService.toLocaleMonthDayDateString(endDate) + ", opt to extend the transition period in the",
						linkUrl: '/workspaces/' + appService.appDetails.ownerData.slug + '/settings/apps',
						linkLabel: 'Workspace settings.',
					}
				} else if (currentDate > endDate) {
					return {
						message: "Deprecated machine type. Your Workflows are now running on Apple Silicon. If youâ€™d like to keep using Intel machines, reach out to support.",
						linkUrl: 'https://discuss.bitrise.io/t/transitioning-from-apple-intel-to-apple-silicon-helpful-links/22615',
						linkLabel: 'Read announcement.',
					}
				}
			}

			viewModel.stackOptionTitle = function(stack) {
				if (stack === null) {
					return stringService.stringReplacedWithParameters(
						"<%= data[:strings][:stack][:default_stack] %>",
						{
							stack_name: viewModel.stackOptionTitle(appService.stack)
						}
					);
				}

				return stack.name || stack.id;
			};

			viewModel.stackOptions = function() {
				var stacks = appService.availableStacks().concat(Stack.invalidStacks);

				return stacks;
			};

			viewModel.onDefaultStackChange = function() {
				appService.dockerImage = viewModel.defaultDockerImagesByStackIDs[appService.stack.id] ? '' : null;

				if(appService.stack.isAgentPoolStack()) {
					return;
				}

				var isPreviousMachineTypeAvailable = viewModel.isMachineTypeAvailableForStack(appService.defaultMachineType, appService.stack);

				if (!isPreviousMachineTypeAvailable) {
					viewModel.setDefaultMachineType(viewModel.firstAvailableMachineTypeForStack(appService.stack.id));
				}

				appService.rollbackVersion = undefined;
				appService.setRollbackVersionFromBitriseYml();
			}

			viewModel.stackGetterSetterForWorkflow = function(workflow, shouldNormalize) {
				if (shouldNormalize === undefined) {
					shouldNormalize = false;
				}

				return function(stack) {
					if (stack === null && shouldNormalize) {
						stack = appService.stack;
					}

					var defaultMachineTypeForStack;
					if (stack) {
						var previousMachineType = viewModel.workflowMachineType(workflow);
						var isPreviousMachineTypeAvailable = viewModel.isMachineTypeAvailableForStack(previousMachineType, stack);

						if (isPreviousMachineTypeAvailable) {
							defaultMachineTypeForStack = previousMachineType;
						} else if (MachineType.defaults) {
							defaultMachineTypeForStack = MachineType.defaults[stack.type];
						}
					}
					stack = workflow.stack(stack, defaultMachineTypeForStack);

					if (stack === null && shouldNormalize) {
						return appService.stack;
					}

					return stack;
				};
			};

			viewModel.setDefaultMachineType = function(machineType) {
				if (machineType === appService.defaultMachineType) {
					return;
				}

				if (machineType && !machineType.isAvailable) {
					return;
				}

				appService.defaultMachineType = machineType;


				viewModel.isRollbackVersionEnabledGetterSetter(false);
			}

			viewModel.setWorkflowMachineType = function(machineType, workflow) {
				if (!machineType.isAvailable) {
					return;
				}

				var stack = viewModel.stackGetterSetterForWorkflow(workflow, true)();
				workflow.machineType(stack.type, machineType, MachineType.all, appService.isOwnerPaying());
			};

			viewModel.workflowMachineType = function(workflow) {
				var stack = viewModel.stackGetterSetterForWorkflow(workflow, true)();
				var workflowMachineType = workflow.machineType(stack.type, undefined, MachineType.all);

				return workflowMachineType || appService.defaultMachineType;
			};

			viewModel.isMachineTypeAvailableForStack = function(previousMachineType, stack) {
				return Object.values(viewModel.stackMachineMap[stack.id] || {}).some(machineTypes =>
					machineTypes.some(machineType => machineType.id === (previousMachineType || {}).id && machineType.type === previousMachineType.type)
				);
			};

			viewModel.firstAvailableMachineTypeForStack = function(selectedStackId) {
				return _.find(MachineType.all, function(aMachineType) {
					return _.contains(aMachineType.availableOnStacks, selectedStackId);
				});
			};

			viewModel.descriptionURLForStack = function(stack) {
				if (stack.descriptionURLGen2 !== undefined) {
					return stack.descriptionURLGen2;
				}

				return stack.descriptionURL;
			};

			viewModel.hasDescriptionURLForStack = function(stack) {
				return !!viewModel.descriptionURLForStack(stack);
			}

			function getShowMachineCreditCost() {
				if (appService.ownerPlanData) {
					return !planServiceUtil.isModernConcurrencyPlan(appService.ownerPlanData.name);
				}
				return true;
			}
		});
})();
