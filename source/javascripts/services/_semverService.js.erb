"use strict";

angular.module("BitriseWorkflowEditor").factory("semverService", function() {
    var semverService = {
        WILDCARD: WILDCARD,
        WILDCARD_REGEX: WILDCARD_REGEX,
        semver: _.template('{{ major }}.{{ minor }}.{{ patch }}'),
    };

    var WILDCARD = 'x';
    var WILDCARD_REGEX = new RegExp('\.' + WILDCARD, 'g');
    var fullVersionRegex = /^\d+\.\d+\.\d+$/g;
    var MAXSEMVER = semverService.semver({
        major: Number.MAX_SAFE_INTEGER,
        minor: Number.MAX_SAFE_INTEGER,
        patch: Number.MAX_SAFE_INTEGER
    });

    var isVersionCompatible = function(wildcard, version) {
        if (!version) {
            return false;
        }

        var semverParts = version.split('.');
        var wildcardParts = wildcard.split('.');

        return _.every(semverParts, function(aSemverPart, index) {
            return aSemverPart == wildcardParts[index] || wildcardParts[index] == WILDCARD;
        });
    };

    var reverseSorter = function(verStr1, verStr2) {
        var ver1 = (verStr1 || MAXSEMVER).split('.');
        var ver2 = (verStr2 || MAXSEMVER).split('.');

        var notEqInd = 0;
        while (ver1[notEqInd] == ver2[notEqInd] && notEqInd < Math.max(ver1.length, ver2.length)) {
            notEqInd++;
        }

        // make WILDCARD always the lowest priority than everything else
        ver1[notEqInd] = ver1[notEqInd] === WILDCARD ? -1 : ver1[notEqInd];
        ver2[notEqInd] = ver2[notEqInd] === WILDCARD ? -1 : ver2[notEqInd];

        // comply with compare interface
        return Math.sign(ver1[notEqInd] - ver2[notEqInd]) * -1;
    };

    semverService.isVersionWildcard = function(version) {
        return version && version.endsWith('.' + WILDCARD);
    };

    semverService.shortenWildcardVersion = function(version) {
        return version && version.replace(WILDCARD_REGEX, '');
    };

    semverService.normalizeVersion = function(version) {
        if (!version || fullVersionRegex.test(version)) {
            return version;
        }

        var semverParts = version.split('.');

        return semverService.semver({
            major: semverParts[0] || WILDCARD,
            minor: semverParts[1] || WILDCARD,
            patch: semverParts[2] || WILDCARD,
        });
    };

    semverService.extractWildcardVersions = function(step, stepCatalogue) {
        var versions = Object.keys(stepCatalogue.steps[step.id]);

        return _.chain(versions)
            .map(function(version) {
                var semVerParts = version.split(".");
                var major = semVerParts[0];
                var minor = semVerParts[1];

                return [
                    semverService.semver({ major: major, minor: minor, patch: WILDCARD }),
                    semverService.semver({ major: major, minor: WILDCARD, patch: WILDCARD })
                ];
            })
            .flatten()
            .tap(function(wVersions) {
                // adding step own version
                wVersions.push(step.version);
            })
            .uniq()
            .value()
            .sort(reverseSorter);
    };

    semverService.resolveVersion = function(step, stepCatalogue) {
        var version = semverService.normalizeVersion(step.version);

        if (!version) {
            return stepCatalogue.latestStepVersions[step.id];
        }

        var compatibleToVersion = _.partial(isVersionCompatible, version);
        var stepVersions = Object.keys(stepCatalogue.steps[step.id]).sort(reverseSorter);

        return _.chain(stepVersions)
            .find(compatibleToVersion)
            .value();
    };

    return semverService;
});