(function() {

"use strict";

angular.module("BitriseWorkflowEditor").factory("stepSourceService", function($q, requestService, Step) {

	var stepSourceService = {
		defaultLibraryURL: undefined,
		libraries: [],
		localSteps: [],
		gitSteps: []
	};

	stepSourceService.stepFromCVS = function(cvs) {
		var step = new Step(cvs);

		var idStartIndex = cvs.indexOf("::") != -1 ? cvs.indexOf("::") + 2 : 0;
		var versionStartIndex = cvs.lastIndexOf("@") != -1 ? cvs.lastIndexOf("@") + 1 : -1;

		var source = idStartIndex > 0 && cvs.slice(0, idStartIndex - 2).length > 0 ? cvs.slice(0, idStartIndex - 2) : null;
		var id = cvs.slice(idStartIndex, versionStartIndex != -1 ? versionStartIndex - 1 : undefined);
		var version = versionStartIndex != -1 && versionStartIndex != cvs.length ? cvs.slice(versionStartIndex) : null;

		switch (source) {
			case "path":
				if (id.length == 0) {
					throw new Error("<%= data[:strings][:step_source_service][:step_info_from_cvs][:no_path] %>");
				}

				step.localPath = id;

				break;
			case "git":
				if (id.length == 0) {
					throw new Error("<%= data[:strings][:step_source_service][:step_info_from_cvs][:no_git_url] %>");
				}

				step.gitURL = id;
				step.version = version;

				break;
			default:
				if (!source && !this.defaultLibraryURL) {
					throw new Error("<%= data[:strings][:step_source_service][:step_info_from_cvs][:no_library] %>");
				}

				if (id.length == 0) {
					throw new Error("<%= data[:strings][:step_source_service][:step_info_from_cvs][:no_id] %>");
				}

				return {
					sourceType: "library",
					libraryURL: source != null ? source : this.defaultLibraryURL,
					id: id,
					version: version
				}

				step.libraryURL = source != null ? source : this.defaultLibraryURL;
				step.id = id;
				step.version = version;

				var library = _.find(stepSourceService.libraries, {
					url: step.libraryURL
				});

				if (library) {
					step.defaultStepConfig = library.specs.steps[step.id].versions[step.version];
				}
		}

		return step;
	};

	stepSourceService.versionsOfStep = function(step) {
		var library = _.find(stepSourceService.libraries, {
			url: step.libraryURL
		});

		if (!library) {
			return undefined;
		}

		return _.keys(library.steps[step.id]);
	};

	stepSourceService.changeStepToVersion = function(step, version) {
		var library = _.find(stepSourceService.libraries, {
			url: step.libraryURL
		});

		if (!library) {
			return undefined;
		}

		var indexOfVersionInCurrentCVS = step.cvs.lastIndexOf("@") != -1 ? step.cvs.lastIndexOf("@") + 1 : -1;
		if (indexOfVersionInCurrentCVS != -1) {
			step.cvs = step.cvs.slice(0, indexOfVersionInCurrentCVS - 1);
		}

		if (version !== null) {
			step.cvs += version;
			step.version = version;
		}
		else {
			step.version = library.latestStepVersions[step.id];
		}

		step.defaultStepConfig = library.specs.steps[step.id].versions[step.version];
	};

	stepSourceService.loadStepWithCVS = function(cvs, requestConfig) {
		switch (source) {
			case "path":
				return loadLocalStepWithCVS(cvs, requestConfig);
			case "git":
				return loadGitStepWithCVS(cvs, requestConfig);
			case "library":
				return loadLibraryStepWithCVS(cvs, requestConfig);
		}
	}

	function loadLocalStepWithCVS(cvs, requestConfig) {
		return $q(function(resolve, reject) {
			var stepInfo = stepSourceService.stepInfoFromCVS(cvs);

			requestService.getLocalStepConfig(stepInfo.path, requestConfig).then(function(stepConfig) {
				var step = new Step(cvs, stepConfig);
				step.localPath = stepInfo.path;

				var indexOfStep = _.findIndex(stepSourceService.localSteps, {
					localPath: stepInfo.path
				});

				if (indexOfStep != -1) {
					stepSourceService.localSteps.splice(indexOfStep, 1);
				}
				stepSourceService.localSteps.push(step);

				resolve();
			}, function(error) {
				console.log(error);
				reject(new Error("<%= data[:strings][:step_source_service][:load_local_step][:error_prefix] %>" + error.message));
			});
		});
	}

	function loadGitStepWithCVS(cvs, requestConfig) {
		return $q(function(resolve, reject) {
			var stepInfo = stepSourceService.stepInfoFromCVS(cvs);

			requestService.getGitStepConfig(stepInfo.gitURL, requestConfig).then(function(stepConfig) {
				var step = new Step(cvs, stepConfig);
				step.gitURL = stepInfo.gitURL;
				step.version = stepInfo.version;

				var indexOfStep = _.findIndex(stepSourceService.gitSteps, {
					gitURL: stepInfo.gitURL
				});

				if (indexOfStep != -1) {
					stepSourceService.gitSteps.splice(indexOfStep, 1);
				}
				stepSourceService.gitSteps.push(step);
			}, function(error) {
				console.log(error);
				reject(new Error("<%= data[:strings][:step_source_service][:load_git_step][:error_prefix] %>" + error.message));
			});
		});
	}

	function loadLibraryStepWithCVS(cvs, requestConfig) {
		return $q(function(resolve, reject) {
			var stepInfo = stepSourceService.stepInfoFromCVS(cvs);
			
			if (_.find(stepSourceService.libraries, {
				url: stepInfo.libraryURL
			})) {
				resolve();

				return;
			}

			requestService.getLibrary(libraryURL, requestConfig).then(function(specs) {
				try {
					var library = {
						url: libraryURL
					};

					library.specs = specs;

					var stepIDs = _.keys(specs.steps).sort();

					library.steps = {};
					library.latestStepVersions = {};
					_.each(stepIDs, function(aStepID) {
						library.steps[aStepID] = {};
						library.latestStepVersions[aStepID] = library.specs.steps[aStepID].latest_version_number;
						library.steps[aStepID] = _.mapObject(library.specs.steps[aStepID].versions, function(aStepConfig, version) {
							var cvs = aStepID + "@" + version;

							return new Step(cvs, undefined, aStepConfig);
						});
					});

					var indexOfLibrary = _.findIndex(stepSourceService.libraries, {
						url: libraryURL
					});

					if (indexOfLibrary != -1) {
						stepSourceService.libraries.splice(indexOfLibrary, 1);
					}
					stepSourceService.libraries.push(library);

					resolve();
				}
				catch (error) {
					console.log(error);
					reject(new Error("<%= data[:strings][:step_source_service][:load_library][:default_error] %>"));
				}
			}, function(error) {
				console.log(error);
				reject(new Error("<%= data[:strings][:step_source_service][:load_library][:error_prefix] %>" + error.message));
			});
		});
	}

	return stepSourceService;

});

})();
