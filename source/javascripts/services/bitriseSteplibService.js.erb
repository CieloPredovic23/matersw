(function() {

"use strict";

angular.module("BitriseWorkflowEditor").factory("bitriseSteplibService", function($http, $q, Step, Variable) {

	var bitriseSteplibService = {
		sourceURL: "https://bitrise-steplib-collection.s3.amazonaws.com/spec.json",
		specs: undefined,
		steps: undefined,
		latestStepVersions: undefined,
	};

	bitriseSteplibService.load = function() {
		if (this.steps) {
			return $q.when();
		}

		var self = this;

		return $q(function(resolve, reject) {
			$http.get(self.sourceURL).then(function(response) {
				try {
					self.specs = response.data;

					var stepIDs = _.keys(response.data.steps).sort();

					self.steps = {};
					self.latestStepVersions = {};
					_.each(stepIDs, function(aStepID) {
						self.steps[aStepID] = {};
						self.latestStepVersions[aStepID] = self.specs.steps[aStepID].latest_version_number;
						self.steps[aStepID] = _.mapObject(self.specs.steps[aStepID].versions, function(aStepConfig, version) {
							var cvs = aStepID + "@" + version;

							return self.stepFromCVS(cvs);
						});
					});

					resolve();
				}
				catch (error) {
					console.log(error);
					reject(new Error("<%= data.strings.bitrise_steplib_service.load.default_error %>"));
				}
			}, function(response) {
				if (!response || !response.data) {
					reject(new Error("<%= data.strings.bitrise_steplib_service.load.default_error %>"));

					return;
				}

				reject(new Error("<%= data.strings.bitrise_steplib_service.load.error_prefix %> " + response.data));
			});
		});
	};

	bitriseSteplibService.stepFromCVS = function(cvs) {
		var cvsSplitBySteplibSource = cvs.split("::");
		if (cvsSplitBySteplibSource.length > 2) {
			throw new Error("<%= data.strings.bitrise_steplib_service.step_from_cvs.multiple_sources %>");
		}

		var steplibSourceURL = cvsSplitBySteplibSource.length > 1 && _.first(cvsSplitBySteplibSource).length > 0 ? _.first(cvsSplitBySteplibSource) : this.sourceURL;
		var isBitriseSteplibStep = steplibSourceURL == this.sourceURL;

		var cvsSplitByVersion = _.last(cvsSplitBySteplibSource).split("@");
		if (cvsSplitByVersion.length > 2) {
			throw new Error("<%= data.strings.bitrise_steplib_service.step_from_cvs.multiple_versions %>");
		}

		var id = _.first(cvsSplitByVersion);
		if (id.length == 0) {
			throw new Error("<%= data.strings.bitrise_steplib_service.step_from_cvs.no_id %>");
		}
		if (isBitriseSteplibStep && !this.specs.steps[id]) {
			throw new ReferenceError("<%= data.strings.bitrise_steplib_service.step_from_cvs.id_not_found %>");
		}

		var version = cvsSplitByVersion.length > 1 ? _.last(cvsSplitByVersion) : (isBitriseSteplibStep ? this.latestStepVersions[id] : null);
		if (!version || version.length == 0) {
			throw new Error("<%= data.strings.bitrise_steplib_service.step_from_cvs.no_version %>");
		}
		if (isBitriseSteplibStep && (!this.specs.steps[id].versions || !this.specs.steps[id].versions[version])) {
			throw new ReferenceError("<%= data.strings.bitrise_steplib_service.step_from_cvs.version_not_found %>");
		}

		var step = isBitriseSteplibStep ? Step.createFromStepConfig(this.specs.steps[id].versions[version]) : new Step();
		step.cvs = cvs;
		step.steplibSourceURL = steplibSourceURL;
		step.id = id;
		step.version = version;

		return step;
	};

	bitriseSteplibService.isBitriseSteplibStep = function(step) {
		return step.steplibSourceURL == this.sourceURL;
	};

	bitriseSteplibService.changeStepToVersion = function(step, version) {
		var stepConfigs = step.stepConfigs;

		step.clear();

		if (version === null) {
			step.cvs = _.first(step.cvs.split("@"));
			step.version = this.latestStepVersions[step.id];
		}
		else {
			step.cvs = _.first(step.cvs.split("@")) + "@" + version;
			step.version = version;
		}

		step.appendStepConfig(this.specs.steps[step.id].versions[version]);
		_.each(stepConfigs, function(aStepConfig) {
			step.appendStepConfig(aStepConfig);
		});
	};

	bitriseSteplibService.updateStepToLatestVersion = function(step) {
		var latestVersion = this.latestStepVersions[step.id];

		this.changeStepToVersion(step, latestVersion);
	};

	bitriseSteplibService.versionsOfStep = function(step) {
		return _.keys(this.steps[step.id]);
	}

	bitriseSteplibService.isStepLatestVersion = function(step) {
		return step.version == this.latestStepVersions[step.id];
	};

	bitriseSteplibService.strippedStepConfigOfStep = function(step) {
		var defaultStepConfig = this.specs.steps[step.id].versions[step.version];
		var strippedStepConfig = {};

		_.each(step.stepConfigs, function(aStepConfig) {
			_.each(aStepConfig, function(aParameter, aParameterID) {
				strippedStepConfig[aParameterID] = angular.copy(aParameter);
			});
		});

		strippedStepConfig.title = step.title;
		strippedStepConfig.summary = step.summary;
		strippedStepConfig.description = step.description;
		strippedStepConfig.source_code_url = step.sourceURL;
		strippedStepConfig.is_always_run = step.isAlwaysRun;
		strippedStepConfig.type_tags = angular.copy(step.typeTags);

		_.each(_.pick(strippedStepConfig, function(aParameter, aParameterID) {
			if (aParameterID == "inputs" || aParameterID == "outputs") {
				return true;
			}

			return angular.equals(aParameter, defaultStepConfig[aParameterID]);
		}), function(aParameter, aParameterID) {
			delete strippedStepConfig[aParameterID];
		});

		var self = this;
		_.each(["inputs", "outputs"], function(aVariableSource) {
			var variables = step[aVariableSource];

			strippedStepConfig[aVariableSource] = []

			_.each(variables, function(aVariable) {
				var defaultVariableConfig = _.find(self.specs.steps[step.id].versions[step.version][aVariableSource], function(aVariableConfig) {
					return Variable.keyFromVariableConfig(aVariableConfig) == aVariable.key;
				});

				var strippedVariableConfig = bitriseSteplibService.strippedVariableConfigOfVariable(aVariable, defaultVariableConfig);
				if (aVariable.value != defaultVariableConfig[aVariable.key] || strippedVariableConfig.opts !== undefined) {
					strippedStepConfig[aVariableSource].push(strippedVariableConfig);
				}
			});

			if (_.isEmpty(strippedStepConfig[aVariableSource])) {
				delete strippedStepConfig[aVariableSource];
			}
		});

		return strippedStepConfig;
	};

	bitriseSteplibService.strippedVariableConfigOfVariable = function(variable, defaultVariableConfig) {
		var strippedVariableConfig = {
			opts: {}
		};

		_.each(variable.variableConfigs, function(aVariableConfig) {
			strippedVariableConfig[variable.key] = aVariableConfig[variable.key];

			_.each(aVariableConfig.opts, function(anOption, anOptionID) {
				strippedVariableConfig.opts[anOptionID] = angular.copy(anOption);
			});
		});

		strippedVariableConfig.opts.title = variable.title;
		strippedVariableConfig.opts.summary = variable.summary;
		strippedVariableConfig.opts.description = variable.description;
		strippedVariableConfig.opts.is_expand = variable.isExpand;
		strippedVariableConfig.opts.skip_if_empty = variable.skipIfEmpty;
		strippedVariableConfig.opts.is_required = variable.isRequired;
		strippedVariableConfig.opts.is_dont_change_value = variable.isDontChangeValue;
		strippedVariableConfig.opts.is_template = variable.isTemplate;
		strippedVariableConfig.opts.value_options = angular.copy(variable.valueOptions);

		_.each(_.pick(strippedVariableConfig.opts, function(anOption, anOptionID) {
			return anOption === undefined || angular.equals(anOption, defaultVariableConfig.opts[anOptionID]);
		}), function(anOption, anOptionID) {
			delete strippedVariableConfig.opts[anOptionID];
		});

		if (_.isEmpty(strippedVariableConfig.opts)) {
			delete strippedVariableConfig["opts"];
		}

		return strippedVariableConfig;
	};

	return bitriseSteplibService;

});

})();
